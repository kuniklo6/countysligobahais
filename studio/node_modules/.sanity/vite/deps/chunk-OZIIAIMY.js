import {
  usePaneRouter
} from "./chunk-NY6CDNOX.js";
import {
  PaneRouterContext,
  PresentationContext,
  PresentationDocumentContext,
  PresentationNavigateContext,
  PresentationParamsContext,
  PresentationSharedStateContext,
  defineDocumentFieldAction,
  defineLocaleResourceBundle,
  definePlugin,
  encodeJsonParams,
  getPublishedId,
  getVersionFromId,
  isDocumentSchemaType,
  isObservable,
  isRecord$4,
  map,
  of,
  pathToString$1,
  route,
  useDocumentPreviewStore,
  useDocumentStore,
  useIntentLink,
  usePerspective,
  useRouter,
  useTranslation,
  useWorkspace,
  v4_default
} from "./chunk-5GYIARJV.js";
import {
  Box,
  Card,
  ChevronRightIcon,
  ComposeIcon,
  DesktopIcon,
  ErrorOutlineIcon,
  Flex,
  InfoOutlineIcon,
  MasterDetailIcon,
  Spinner,
  Stack,
  Text,
  WarningOutlineIcon,
  at,
  getTheme_v2,
  rem,
  rt
} from "./chunk-GWSOWVM6.js";
import {
  require_compiler_runtime
} from "./chunk-5I4Y4JKH.js";
import {
  require_jsx_runtime
} from "./chunk-GRLST4WI.js";
import {
  require_react
} from "./chunk-3SNRL2IO.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@sanity/preview-url-secret/dist/constants.js
var schemaType = "sanity.previewUrlSecret";
var schemaIdPrefix = "sanity-preview-url-secret";
var schemaIdSingleton = `${schemaIdPrefix}.share-access`;
var schemaTypeSingleton = "sanity.previewUrlShareAccess";
var apiVersion = "2025-02-19";
var urlSearchParamPreviewSecret = "sanity-preview-secret";
var urlSearchParamPreviewPathname = "sanity-preview-pathname";
var urlSearchParamPreviewPerspective = "sanity-preview-perspective";
var urlSearchParamVercelProtectionBypass = "x-vercel-protection-bypass";
var urlSearchParamVercelSetBypassCookie = "x-vercel-set-bypass-cookie";
var SECRET_TTL = 3600;
var fetchSecretQuery = (
  /* groq */
  `*[_type == "${schemaType}" && secret == $secret && dateTime(_updatedAt) > dateTime(now()) - ${SECRET_TTL}][0]{
    _id,
    _updatedAt,
    secret,
    studioUrl,
  }`
);
var fetchSharedAccessQuery = (
  /* groq */
  `*[_id == "${schemaIdSingleton}" && _type == "${schemaTypeSingleton}"][0].secret`
);
var fetchSharedAccessSecretQuery = (
  /* groq */
  `*[_id == "${schemaIdSingleton}" && _type == "${schemaTypeSingleton}" && secret == $secret][0]{
  secret,
  studioUrl,
}`
);
var deleteExpiredSecretsQuery = (
  /* groq */
  `*[_type == "${schemaType}" && dateTime(_updatedAt) <= dateTime(now()) - ${SECRET_TTL}]`
);
var vercelProtectionBypassSchemaType = "sanity.vercelProtectionBypass";
var vercelProtectionBypassSchemaId = `${schemaIdPrefix}.vercel-protection-bypass`;
var fetchVercelProtectionBypassSecret = (
  /* groq */
  `*[_id == "${vercelProtectionBypassSchemaId}" && _type == "${vercelProtectionBypassSchemaType}"][0].secret`
);
var tag = "sanity.preview-url-secret";

// node_modules/sanity/lib/_chunks-es/presentation.js
var import_compiler_runtime = __toESM(require_compiler_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var useSharedState = (key, value) => {
  const $ = (0, import_compiler_runtime.c)(5), context = (0, import_react.useContext)(PresentationSharedStateContext);
  if (!context)
    throw new Error("Preview Snapshots context is missing");
  const {
    setValue
  } = context;
  let t0, t1;
  $[0] !== key || $[1] !== setValue || $[2] !== value ? (t0 = () => {
    setValue(key, value);
  }, t1 = [key, value, setValue], $[0] = key, $[1] = setValue, $[2] = value, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), (0, import_react.useEffect)(t0, t1);
};
var DEFAULT_TOOL_ICON = ComposeIcon;
var DEFAULT_TOOL_NAME = "presentation";
var DEFAULT_TOOL_TITLE = "Presentation";
var EDIT_INTENT_MODE = "presentation";
var MAX_TIME_TO_OVERLAYS_CONNECTION = 3e3;
var API_VERSION = apiVersion;
var MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = 1e3;
var LOADER_QUERY_GC_INTERVAL = 3e4;
var POPUP_CHECK_INTERVAL = 1e3;
var presentationLocaleNamespace = "presentation";
var presentationUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: presentationLocaleNamespace,
  resources: () => import("./resources8-HPF4FXBM.js")
});
function usePresentationPerspectiveStack() {
  const $ = (0, import_compiler_runtime.c)(3), {
    perspectiveStack
  } = usePerspective(), paneRouter = (0, import_react.useContext)(PaneRouterContext);
  if (!paneRouter)
    throw new Error("PaneRouter not found");
  const scheduledDraftPerspective = paneRouter.params?.scheduledDraft;
  if (scheduledDraftPerspective) {
    let t0;
    return $[0] !== perspectiveStack || $[1] !== scheduledDraftPerspective ? (t0 = [scheduledDraftPerspective, ...perspectiveStack], $[0] = perspectiveStack, $[1] = scheduledDraftPerspective, $[2] = t0) : t0 = $[2], t0;
  }
  return perspectiveStack;
}
var INITIAL_STATE = {
  locations: []
};
function useDocumentLocations(props) {
  const $ = (0, import_compiler_runtime.c)(23), {
    id,
    resolvers,
    type,
    version
  } = props, documentStore = useDocumentStore(), documentPreviewStore = useDocumentPreviewStore(), perspectiveStack = usePresentationPerspectiveStack(), [locationsState, setLocationsState] = (0, import_react.useState)(INITIAL_STATE), resolver = resolvers && (typeof resolvers == "function" ? resolvers : resolvers[type.name]), [locationsStatus, setLocationsStatus] = (0, import_react.useState)(resolver ? "resolving" : "empty");
  let t0;
  bb0: {
    if (!resolver) {
      t0 = void 0;
      break bb0;
    }
    if (typeof resolver == "function") {
      let t13;
      if ($[0] !== documentStore || $[1] !== id || $[2] !== perspectiveStack || $[3] !== resolver || $[4] !== type.name || $[5] !== version) {
        const params = {
          id,
          type: type.name,
          version,
          perspectiveStack
        }, _result = resolver(params, {
          documentStore
        });
        t13 = isObservable(_result) ? _result : of(_result), $[0] = documentStore, $[1] = id, $[2] = perspectiveStack, $[3] = resolver, $[4] = type.name, $[5] = version, $[6] = t13;
      } else
        t13 = $[6];
      t0 = t13;
      break bb0;
    }
    if ("select" in resolver && "resolve" in resolver) {
      let t13;
      if ($[7] !== documentPreviewStore || $[8] !== id || $[9] !== perspectiveStack || $[10] !== resolver || $[11] !== type) {
        const doc = {
          _type: "reference",
          _ref: id
        }, _type = {
          ...type,
          preview: {
            select: resolver.select
          }
        }, options = {
          perspective: perspectiveStack
        };
        let t22;
        $[13] !== resolver ? (t22 = (preview) => resolver.resolve(preview.snapshot || null), $[13] = resolver, $[14] = t22) : t22 = $[14], t13 = documentPreviewStore.observeForPreview(doc, _type, options).pipe(map(t22)), $[7] = documentPreviewStore, $[8] = id, $[9] = perspectiveStack, $[10] = resolver, $[11] = type, $[12] = t13;
      } else
        t13 = $[12];
      t0 = t13;
      break bb0;
    }
    let t12;
    $[15] !== resolver ? (t12 = of(resolver), $[15] = resolver, $[16] = t12) : t12 = $[16], t0 = t12;
  }
  const result = t0;
  let t1, t2;
  $[17] !== result ? (t1 = () => {
    const sub = result?.subscribe((state) => {
      setLocationsState(state || INITIAL_STATE), setLocationsStatus(state ? "resolved" : "empty");
    });
    return () => sub?.unsubscribe();
  }, t2 = [result], $[17] = result, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), (0, import_react.useEffect)(t1, t2);
  let t3;
  return $[20] !== locationsState || $[21] !== locationsStatus ? (t3 = {
    state: locationsState,
    status: locationsStatus
  }, $[20] = locationsState, $[21] = locationsStatus, $[22] = t3) : t3 = $[22], t3;
}
function usePresentationTool(t0) {
  const throwOnMissingContext = t0 === void 0 ? true : t0, presentation = (0, import_react.useContext)(PresentationContext);
  if (throwOnMissingContext && !presentation)
    throw new Error("Presentation context is missing");
  return presentation;
}
function useCurrentPresentationToolName() {
  return usePresentationTool(false)?.name ?? void 0;
}
var TONE_ICONS = {
  positive: InfoOutlineIcon,
  caution: WarningOutlineIcon,
  critical: ErrorOutlineIcon
};
function LocationsBanner(props) {
  const $ = (0, import_compiler_runtime.c)(39), {
    documentId,
    options,
    resolvers,
    schemaType: schemaType2,
    showPresentationTitle,
    version
  } = props;
  let t0;
  $[0] !== documentId || $[1] !== resolvers || $[2] !== schemaType2 || $[3] !== version ? (t0 = {
    id: documentId,
    version,
    resolvers,
    type: schemaType2
  }, $[0] = documentId, $[1] = resolvers, $[2] = schemaType2, $[3] = version, $[4] = t0) : t0 = $[4];
  const {
    state,
    status
  } = useDocumentLocations(t0), isResolving = status === "resolving", {
    locations,
    message,
    tone
  } = state, locationsCount = locations?.length || 0, {
    t
  } = useTranslation(presentationLocaleNamespace), presentation = (0, import_react.useContext)(PresentationContext), presentationName = presentation?.name, [expanded, setExpanded] = (0, import_react.useState)(false);
  let t1;
  $[5] !== locationsCount ? (t1 = () => {
    locationsCount && setExpanded(_temp$2);
  }, $[5] = locationsCount, $[6] = t1) : t1 = $[6];
  const toggle = t1;
  let t2;
  $[7] !== isResolving || $[8] !== locationsCount || $[9] !== message || $[10] !== t ? (t2 = isResolving ? t("locations-banner.resolving.text") : message || t("locations-banner.locations-count", {
    count: locationsCount
  }), $[7] = isResolving, $[8] = locationsCount, $[9] = message, $[10] = t, $[11] = t2) : t2 = $[11];
  const title = t2, ToneIcon = tone ? TONE_ICONS[tone] : void 0;
  if (!resolvers || status === "empty")
    return null;
  let t3;
  $[12] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    margin: -1
  }, $[12] = t3) : t3 = $[12];
  let t4;
  $[13] !== ToneIcon || $[14] !== locations || $[15] !== options || $[16] !== showPresentationTitle || $[17] !== title || $[18] !== tone ? (t4 = !locations && (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, padding: 3, children: [
    tone && ToneIcon && (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(ToneIcon, {}) }) }),
    (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "medium", children: [
      showPresentationTitle && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        options.title || DEFAULT_TOOL_TITLE,
        " · "
      ] }),
      title
    ] }) })
  ] }), $[13] = ToneIcon, $[14] = locations, $[15] = options, $[16] = showPresentationTitle, $[17] = title, $[18] = tone, $[19] = t4) : t4 = $[19];
  let t5;
  $[20] !== documentId || $[21] !== expanded || $[22] !== isResolving || $[23] !== locations || $[24] !== locationsCount || $[25] !== options || $[26] !== presentation || $[27] !== presentationName || $[28] !== schemaType2 || $[29] !== showPresentationTitle || $[30] !== title || $[31] !== toggle ? (t5 = locations && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(Card, { as: locationsCount ? "button" : void 0, onClick: toggle, padding: 3, radius: 1, tone: "inherit", children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 3, children: [
      (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: isResolving ? (0, import_jsx_runtime.jsx)(Spinner, { size: 1 }) : (0, import_jsx_runtime.jsx)(Text, { size: 1, children: locationsCount === 0 ? (0, import_jsx_runtime.jsx)(InfoOutlineIcon, {}) : (0, import_jsx_runtime.jsx)(ChevronRightIcon, { style: {
        transform: `rotate(${expanded ? "90deg" : 0})`,
        transition: "transform 100ms ease-in-out"
      } }) }) }),
      (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "medium", children: [
        showPresentationTitle && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
          options.title || DEFAULT_TOOL_TITLE,
          " · "
        ] }),
        title
      ] }) })
    ] }) }),
    (0, import_jsx_runtime.jsx)(Stack, { hidden: !expanded, marginTop: 1, space: 1, children: locations.map((l) => {
      let active = false;
      return (options.name || DEFAULT_TOOL_NAME) === presentationName && presentation?.params.preview && (active = areUrlsMatching(presentation.params.preview, l.href)), (0, import_jsx_runtime.jsx)(LocationItem, { active, documentId, documentType: schemaType2.name, node: l, toolName: options.name || DEFAULT_TOOL_NAME }, l.href);
    }) })
  ] }), $[20] = documentId, $[21] = expanded, $[22] = isResolving, $[23] = locations, $[24] = locationsCount, $[25] = options, $[26] = presentation, $[27] = presentationName, $[28] = schemaType2, $[29] = showPresentationTitle, $[30] = title, $[31] = toggle, $[32] = t5) : t5 = $[32];
  let t6;
  $[33] !== t4 || $[34] !== t5 ? (t6 = (0, import_jsx_runtime.jsxs)("div", { style: t3, children: [
    t4,
    t5
  ] }), $[33] = t4, $[34] = t5, $[35] = t6) : t6 = $[35];
  let t7;
  return $[36] !== t6 || $[37] !== tone ? (t7 = (0, import_jsx_runtime.jsx)(Card, { padding: 1, radius: 2, border: true, tone, children: t6 }), $[36] = t6, $[37] = tone, $[38] = t7) : t7 = $[38], t7;
}
function _temp$2(v) {
  return !v;
}
function LocationItem(props) {
  const $ = (0, import_compiler_runtime.c)(27), {
    documentId,
    documentType,
    node,
    active,
    toolName
  } = props, presentation = (0, import_react.useContext)(PresentationContext), currentPresentationToolName = useCurrentPresentationToolName(), isCurrentTool = toolName === currentPresentationToolName, navigate = presentation?.navigate, {
    params: paneParams
  } = usePaneRouter(), t0 = presentation?.structureParams;
  let t1;
  $[0] !== documentId || $[1] !== documentType || $[2] !== node.href || $[3] !== paneParams || $[4] !== t0 || $[5] !== toolName ? (t1 = {
    intent: "edit",
    params: {
      id: documentId,
      type: documentType,
      mode: "presentation",
      presentation: toolName,
      ...t0,
      ...paneParams,
      preview: node.href
    }
  }, $[0] = documentId, $[1] = documentType, $[2] = node.href, $[3] = paneParams, $[4] = t0, $[5] = toolName, $[6] = t1) : t1 = $[6];
  const presentationLinkProps = useIntentLink(t1);
  let t2;
  $[7] !== navigate || $[8] !== node.href ? (t2 = () => {
    navigate?.({
      params: {
        preview: node.href
      }
    });
  }, $[7] = navigate, $[8] = node.href, $[9] = t2) : t2 = $[9];
  const handleCurrentToolClick = t2;
  let t3;
  $[10] !== isCurrentTool || $[11] !== presentationLinkProps ? (t3 = isCurrentTool ? {} : presentationLinkProps, $[10] = isCurrentTool, $[11] = presentationLinkProps, $[12] = t3) : t3 = $[12];
  const t4 = isCurrentTool ? handleCurrentToolClick : presentationLinkProps.onClick;
  let t5;
  $[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DesktopIcon, {}) }) }), $[13] = t5) : t5 = $[13];
  let t6;
  $[14] !== node.title ? (t6 = (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: node.title }), $[14] = node.title, $[15] = t6) : t6 = $[15];
  let t7;
  $[16] !== node.href ? (t7 = (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, textOverflow: "ellipsis", children: node.href }), $[16] = node.href, $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== t6 || $[19] !== t7 ? (t8 = (0, import_jsx_runtime.jsxs)(Flex, { gap: 3, children: [
    t5,
    (0, import_jsx_runtime.jsxs)(Stack, { flex: 1, space: 2, children: [
      t6,
      t7
    ] })
  ] }), $[18] = t6, $[19] = t7, $[20] = t8) : t8 = $[20];
  let t9;
  return $[21] !== active || $[22] !== node.href || $[23] !== t3 || $[24] !== t4 || $[25] !== t8 ? (t9 = (0, import_jsx_runtime.jsx)(Card, { ...t3, as: "a", onClick: t4, padding: 3, radius: 1, pressed: active, tone: "inherit", children: t8 }, node.href), $[21] = active, $[22] = node.href, $[23] = t3, $[24] = t4, $[25] = t8, $[26] = t9) : t9 = $[26], t9;
}
function areUrlsMatching(previewUrlString, locationUrlString) {
  try {
    const previewUrl = new URL(previewUrlString, location.origin), locationUrl = new URL(locationUrlString, previewUrl.origin);
    if (previewUrl.origin !== locationUrl.origin || previewUrl.pathname !== locationUrl.pathname)
      return false;
    const locationParams = new URLSearchParams(locationUrl.search), previewParams = new URLSearchParams(previewUrl.search);
    for (const [key, value] of locationParams.entries())
      if (previewParams.get(key) !== value)
        return false;
    return true;
  } catch {
    return false;
  }
}
var LocationStack = at.div((props) => {
  const theme = getTheme_v2(props.theme);
  return rt`
    display: flex;
    flex-direction: column;
    gap: ${rem(theme.space[2])};
    min-height: ${rem(42)};
    margin-bottom: ${rem(theme.space[5])};

    &:empty {
      display: none;
    }
  `;
});
function PresentationDocumentHeader(props) {
  const $ = (0, import_compiler_runtime.c)(18), {
    documentId,
    options,
    schemaType: schemaType2,
    version
  } = props, context = (0, import_react.useContext)(PresentationDocumentContext);
  let contextOptions, resolvers, t0;
  $[0] !== context?.options ? (contextOptions = context?.options || [], resolvers = contextOptions.map(_temp$1), t0 = resolvers.some(Boolean), $[0] = context?.options, $[1] = contextOptions, $[2] = resolvers, $[3] = t0) : (contextOptions = $[1], resolvers = $[2], t0 = $[3]);
  const hasResolvers = t0;
  if (context && context.options[0] !== options || !hasResolvers)
    return null;
  let t1;
  if ($[4] !== contextOptions || $[5] !== documentId || $[6] !== resolvers || $[7] !== schemaType2 || $[8] !== version) {
    let t22;
    $[10] !== contextOptions.length || $[11] !== documentId || $[12] !== resolvers || $[13] !== schemaType2 || $[14] !== version ? (t22 = (_options, idx) => (0, import_jsx_runtime.jsx)(LocationsBanner, { documentId, options: _options, resolvers: resolvers[idx], schemaType: schemaType2, showPresentationTitle: contextOptions.length > 1, version }, idx), $[10] = contextOptions.length, $[11] = documentId, $[12] = resolvers, $[13] = schemaType2, $[14] = version, $[15] = t22) : t22 = $[15], t1 = contextOptions.map(t22), $[4] = contextOptions, $[5] = documentId, $[6] = resolvers, $[7] = schemaType2, $[8] = version, $[9] = t1;
  } else
    t1 = $[9];
  let t2;
  return $[16] !== t1 ? (t2 = (0, import_jsx_runtime.jsx)(LocationStack, { children: t1 }), $[16] = t1, $[17] = t2) : t2 = $[17], t2;
}
function _temp$1(o) {
  return o.resolve?.locations || o.locate;
}
function PresentationDocumentProvider(props) {
  const $ = (0, import_compiler_runtime.c)(15), {
    children,
    options
  } = props, parent = (0, import_react.useContext)(PresentationDocumentContext), parentRegister = parent?.register, [optionsArray, setOptionsArray] = (0, import_react.useState)(_temp);
  let t0;
  $[0] !== parentRegister ? (t0 = (options_0) => parentRegister ? parentRegister(options_0) : (setOptionsArray((prev) => [options_0].concat(prev)), () => {
    setOptionsArray((prev_0) => prev_0.filter((o) => o !== options_0));
  }), $[0] = parentRegister, $[1] = t0) : t0 = $[1];
  const register = t0, t1 = parent?.options || optionsArray;
  let t2;
  $[2] !== register || $[3] !== t1 ? (t2 = {
    options: t1,
    register
  }, $[2] = register, $[3] = t1, $[4] = t2) : t2 = $[4];
  const context = t2;
  let t3;
  $[5] !== register ? (t3 = (options_1) => register(options_1), $[5] = register, $[6] = t3) : t3 = $[6];
  const registerEffectEvent = (0, import_react.useEffectEvent)(t3);
  let t4;
  $[7] !== options || $[8] !== registerEffectEvent ? (t4 = () => registerEffectEvent(options), $[7] = options, $[8] = registerEffectEvent, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== options ? (t5 = [options], $[10] = options, $[11] = t5) : t5 = $[11], (0, import_react.useLayoutEffect)(t4, t5);
  let t6;
  return $[12] !== children || $[13] !== context ? (t6 = (0, import_jsx_runtime.jsx)(PresentationDocumentContext.Provider, { value: context, children }), $[12] = children, $[13] = context, $[14] = t6) : t6 = $[14], t6;
}
function _temp() {
  return [];
}
function useOpenInStructureAction(props) {
  const $ = (0, import_compiler_runtime.c)(13), {
    documentId,
    documentType,
    path
  } = props, workspace = useWorkspace(), {
    navigateIntent
  } = useRouter(), presentation = (0, import_react.useContext)(PresentationContext), t0 = presentation?.name || DEFAULT_TOOL_NAME;
  let t1;
  $[0] !== documentId || $[1] !== documentType || $[2] !== t0 || $[3] !== workspace.tools ? (t1 = findStructureTool(workspace.tools, documentId, documentType, t0), $[0] = documentId, $[1] = documentType, $[2] = t0, $[3] = workspace.tools, $[4] = t1) : t1 = $[4];
  const defaultStructureTool = t1, t2 = !presentation || path.length > 0 || !defaultStructureTool, t3 = defaultStructureTool?.icon || MasterDetailIcon, t4 = `Open in ${defaultStructureTool?.title || "Structure"}`;
  let t5;
  return $[5] !== documentId || $[6] !== documentType || $[7] !== navigateIntent || $[8] !== path || $[9] !== t2 || $[10] !== t3 || $[11] !== t4 ? (t5 = {
    type: "action",
    hidden: t2,
    icon: t3,
    title: t4,
    onAction() {
      navigateIntent("edit", {
        id: documentId,
        type: documentType,
        mode: "structure",
        path: pathToString$1(path)
      });
    },
    renderAsButton: true
  }, $[5] = documentId, $[6] = documentType, $[7] = navigateIntent, $[8] = path, $[9] = t2, $[10] = t3, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
}
var openInStructure = defineDocumentFieldAction({
  name: "presentation/openInStructure",
  useAction: useOpenInStructureAction
});
function findStructureTool(tools, documentId, documentType, presentationToolName) {
  const results = tools.filter((t) => t.name !== presentationToolName).map((t) => {
    const match = t.canHandleIntent?.("edit", {
      id: documentId,
      type: documentType,
      mode: "structure"
    }, {});
    return {
      tool: t,
      match
    };
  }), modeMatches = results.filter((t) => isRecord$4(t.match) && t.match.mode);
  return modeMatches.length > 0 ? modeMatches[0].tool : results.filter((t) => t.match)[0]?.tool;
}
var preservedSearchParamKeys = ["preview", "viewport"];
function getIntentState(intent, params, routerState, payload) {
  const {
    id,
    mode,
    path,
    presentation,
    type,
    ...searchParams
  } = params, _searchParams = {
    ...(routerState?._searchParams || []).filter(([key]) => preservedSearchParamKeys.includes(key)).reduce((acc, [key, value]) => ({
      ...acc,
      [key]: value
    }), {}),
    ...searchParams
  };
  return intent === "edit" && id ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", {
    type: type || "*",
    id: getPublishedId(id),
    path,
    _searchParams: Object.entries(_searchParams)
  }) : intent === "create" ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", payload && typeof payload == "object" && (_searchParams.templateParams = encodeJsonParams(payload)), {
    type: type || "*",
    id: id || v4_default(),
    _searchParams: Object.entries(_searchParams)
  }) : {
    intent,
    params,
    payload
  };
}
function PresentationSpinner() {
  const $ = (0, import_compiler_runtime.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", style: {
    width: "100%"
  }, children: (0, import_jsx_runtime.jsx)(Spinner, {}) }), $[0] = t0) : t0 = $[0], t0;
}
var router = route.create("/", {
  __unsafe_disableScopedSearchParams: true
}, [route.intents("/intent"), route.create(":type", [route.create(":id", [route.create(":path")])])]);
var PresentationTool = (0, import_react.lazy)(() => import("./PresentationToolGrantsCheck-ZILLDBFD.js"));
var BroadcastDisplayedDocument = (0, import_react.lazy)(() => import("./BroadcastDisplayedDocument-4L4OSXOA.js"));
function defineLocations(resolver) {
  return resolver;
}
function defineDocuments(resolvers) {
  return resolvers;
}
var presentationTool = definePlugin((options) => {
  const toolName = options.name || DEFAULT_TOOL_NAME;
  "locate" in options && console.warn("Presentation’s `locate` option is deprecated. Use `resolve.locations` instead.");
  const hasLocationsResolver = !!(options.resolve?.locations || options.locate);
  function PresentationDocumentInput(props) {
    const $ = (0, import_compiler_runtime.c)(22), value = props.value;
    let t0;
    $[0] !== value?._id ? (t0 = value?._id ? getPublishedId(value?._id) : void 0, $[0] = value?._id, $[1] = t0) : t0 = $[1];
    const documentId = t0;
    let t1;
    $[2] !== value ? (t1 = value?._id ? getVersionFromId(value._id) : void 0, $[2] = value, $[3] = t1) : t1 = $[3];
    const documentVersion = t1;
    if (isDocumentSchemaType(props.schemaType)) {
      let t22;
      $[4] !== documentId || $[5] !== documentVersion || $[6] !== props.schemaType ? (t22 = hasLocationsResolver && documentId && (0, import_jsx_runtime.jsx)(PresentationDocumentHeader, { documentId, version: documentVersion, options, schemaType: props.schemaType }), $[4] = documentId, $[5] = documentVersion, $[6] = props.schemaType, $[7] = t22) : t22 = $[7];
      let t3;
      $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = (0, import_jsx_runtime.jsx)(PresentationSpinner, {}), $[8] = t3) : t3 = $[8];
      let t4;
      $[9] !== props ? (t4 = props.renderDefault(props), $[9] = props, $[10] = t4) : t4 = $[10];
      let t5;
      $[11] !== t4 ? (t5 = (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: t3, children: t4 }), $[11] = t4, $[12] = t5) : t5 = $[12];
      let t6;
      $[13] !== documentId || $[14] !== value ? (t6 = (0, import_jsx_runtime.jsx)(import_react.Suspense, { children: (0, import_jsx_runtime.jsx)(BroadcastDisplayedDocument, { value }, documentId) }, "broadcast-displayed-document"), $[13] = documentId, $[14] = value, $[15] = t6) : t6 = $[15];
      let t7;
      return $[16] !== t22 || $[17] !== t5 || $[18] !== t6 ? (t7 = (0, import_jsx_runtime.jsxs)(PresentationDocumentProvider, { options, children: [
        t22,
        t5,
        t6
      ] }), $[16] = t22, $[17] = t5, $[18] = t6, $[19] = t7) : t7 = $[19], t7;
    }
    let t2;
    return $[20] !== props ? (t2 = props.renderDefault(props), $[20] = props, $[21] = t2) : t2 = $[21], t2;
  }
  function canHandleCreateIntent(params) {
    return !("type" in params) || "presentation" in params && params.presentation !== toolName ? false : "template" in params ? {
      template: true
    } : true;
  }
  function canHandleEditIntent(params) {
    return !("type" in params) || !("id" in params) || "presentation" in params && params.presentation !== toolName ? false : "mode" in params ? {
      mode: params.mode === EDIT_INTENT_MODE
    } : true;
  }
  return {
    i18n: {
      bundles: [presentationUsEnglishLocaleBundle]
    },
    document: {
      unstable_fieldActions: (prev) => [
        ...prev.filter((a) => a.name !== openInStructure.name),
        // prevent duplication
        openInStructure
      ]
    },
    form: {
      components: {
        input: PresentationDocumentInput
      }
    },
    tools: [{
      icon: options.icon || DEFAULT_TOOL_ICON,
      name: toolName,
      title: options.title || DEFAULT_TOOL_TITLE,
      component: PresentationTool,
      options,
      canHandleIntent(intent, params) {
        return intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : false;
      },
      getIntentState,
      router,
      __internalApplicationType: "sanity/presentation"
    }]
  };
});
function usePresentationNavigate() {
  const navigate = (0, import_react.useContext)(PresentationNavigateContext);
  if (!navigate)
    throw new Error("Presentation navigate context is missing");
  return navigate;
}
function usePresentationParams(t0) {
  const throwOnMissingContext = t0 === void 0 ? true : t0, params = (0, import_react.useContext)(PresentationParamsContext);
  if (throwOnMissingContext && !params)
    throw new Error("Presentation params context is missing");
  return params;
}

export {
  schemaType,
  schemaIdSingleton,
  schemaTypeSingleton,
  apiVersion,
  urlSearchParamPreviewSecret,
  urlSearchParamPreviewPathname,
  urlSearchParamPreviewPerspective,
  urlSearchParamVercelProtectionBypass,
  urlSearchParamVercelSetBypassCookie,
  SECRET_TTL,
  fetchSharedAccessQuery,
  deleteExpiredSecretsQuery,
  fetchVercelProtectionBypassSecret,
  tag,
  useSharedState,
  DEFAULT_TOOL_NAME,
  EDIT_INTENT_MODE,
  MAX_TIME_TO_OVERLAYS_CONNECTION,
  API_VERSION,
  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,
  LOADER_QUERY_GC_INTERVAL,
  POPUP_CHECK_INTERVAL,
  presentationLocaleNamespace,
  usePresentationTool,
  PresentationSpinner,
  defineLocations,
  defineDocuments,
  presentationTool,
  usePresentationNavigate,
  usePresentationParams
};
//# sourceMappingURL=chunk-OZIIAIMY.js.map
